#!/bin/bash

##
# File: toolbox
# Author: Giovane Boaviagem <giovanebribeiro@gmail.com>
# Description: Toolbox for arch linux servers
# Since: 21/02/2013
#
#  This file is free software: you may copy, redistribute and/or modify it  
#  under the terms of the GNU General Public License as published by the  
#  Free Software Foundation, either version 2 of the License, or (at your  
#  option) any later version.  
#  
#  This file is distributed in the hope that it will be useful, but  
#  WITHOUT ANY WARRANTY; without even the implied warranty of  
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
#  General Public License for more details.  
#  
#  You should have received a copy of the GNU General Public License  
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.  
##

###################################################################
######### UTIL FUNCTIONS AND GLOBAL VARIABLES #####################
###################################################################

# Global Variables
VERSION="1.0"
AUTHOR="Giovane Boaviagem"
LOG_FILE="/var/log/toolbox.log"
mail_content="/home/giovane/toolbox.mail"

##
# log()
# @param $1 function name
# @param $2 log message
##
log(){
	echo -e "$2"
	echo -e "$2 " >> $mail_content
	echo -e "[$(date '+%d/%m/%Y %H:%M:%S')] $1: $2 " >> $LOG_FILE
}

##
# question()
##
question(){
    printf "\e[1;33m?? \e[1;37m$1 \e[1;30m[\e[1;32mS\e[1;30m/\e[1;31mN\e[1;30m]:\e[m "
    read out

    case "$out" in
        's' | 'S' )
            resp=1
            ;;
        * )
            resp=0
            ;;
    esac

    if [ "x$2" == "xecho" ]; then
        echo $resp
    else
        question=$resp
    fi

    return 0
}

##
# send_mail()
# @param $1 The e-mail address to send
##
send_mail(){
	addr=$1
	if [ ! -f "/usr/bin/mailx" ] ; then
		log "util" "You must have the heirloom-mailx package"
		return 1
	fi
	
	mailx -s "[TOOLBOX] $HOSTNAME -  Status Report" $1 < $mail_content

	rm $mail_content
}

##
# version()
##
version(){
	echo "toolbox $VERSION"
    echo "Author: $AUTHOR"
}

##
# usage()
##
usage(){
	version
    echo "syntax: $0 [OPTIONS] [PARAMS]"
    echo "  OPTIONS:"
    echo "    -h            					: Shows thes help"    
    echo "    -v          						: Shows the version"
    echo "    -b	PARENT_BACKUP_FOLDER        : Do a complete backup to a folder under PARENT_BACKUP_FOLDER"
    echo "    -r    RESTORE_FOLDER  			: Do a complete restore from RESTORE_FOLDER to a '/' directory"
    echo "    -c   								: Complete cleaning"
}

###################################################################
################ BACKUP AND RESTORE FUNCTIONS #####################
###################################################################

#
# backup()
# @param $1: Parent folder for backup
#
backup(){
	DATETAG=$(date +%d-%m-%Y)		
	
	BACKUP_PARENT_FOLDER="$1"
	SRC="/*"
	SNAP="$BACKUP_PARENT_FOLDER/latest"	
	BKP_FOLDER="$BACKUP_PARENT_FOLDER/$DATETAG"
	OPTS="-aAXv --link-dest=$SNAP --exclude=/dev --exclude=/proc --exclude=/sys --exclude=/tmp --exclude=/run --exclude=/mnt --exclude=/media --exclude=/lost+found --exclude=/home/*/.gvfs"
	
	
	
	# if the rsync is not installed, exit
	if [ ! -f /usr/bin/rsync ] ; then
		log "backup" "rsync must be installed on the system\n"
		return 1
	fi
	
	
	# run this process with low priority
	ionice -c 3 -p $$
	renice +12 -p $$
	# create the folder if don't exist:
	if [ ! -d "$BACKUP_PARENT_FOLDER" ] ; then
		mkdir -p $BACKUP_PARENT_FOLDER
	fi

	#sync
	log "backup" "**** Backup:"
	START=$(date +%s)
	rsync $OPTS $SRC $BKP_FOLDER
	rm -f $SNAP
	ln -s $BKP_FOLDER $SNAP	
	FINISH=$(date +%s)
	
	log "backup" "** Backup of $DATETAG: $(( ($FINISH-$START) / 60  )) minutes, $((  ($FINISH-$START) % 60 )) seconds\n"
}

##
# restore()
# @param $1 Folder for restore
##
restore(){
	DATETAG=$(date +%d-%m-%Y)
	LOG_FOLDER="$LOG_FOLDER/restore"
	

	# if the log folder don't exist, create
	if [ ! -d $LOG_FOLDER ] ; then		
		mkdir -p $LOG_FOLDER
	fi
	
	# if the rsync is not installed, exit
	if [ ! -f /usr/bin/rsync ] ; then
		log "backup" "rsync must be installed on the system"
		exit 1
	fi
	
	log "restore" "Not implemented yet."
}

###################################################################
################ FUNCTIONS FOR CLEANING ###########################
###################################################################

filename="cleaner"
DATETAG=$(date +%d-%m-%Y)

##
# clean_logs()
##
clean_logs(){
	logs_folder="/var/log"
	before=$(du -sh $logs_folder)
	
	find "$logs_folder" | 
		while read line; do
			if [ -f $line ] ; then
				echo '' > $line
			fi
		done

	log "$filename" "**** Log Folder:"
	log "$filename" "** Before: $before"
	log "$filename" "** After: $(du -sh $logs_folder) \n"
}

##
# clean_unnecessary_packages_pacman()
##
clean_unnecessary_packages_pacman(){
	log "$filename" "**** Using pacman to remove unnecessary packages\n"
	
	_packages=$(pacman -Qdtq)
	
	if [ -n $_packages ] ; then
		pacman -Rns $_packages
		teste=`echo $?`
		if [ $teste == "0" ] ; then
			log "$filename" "** $(echo $_packages | wc -l) packages removed($_packages)\n"
		else
			log "$filename" "** Fail to execute: pacman -Rns $_packages\n"
			return 1
		fi
	else
		log "$filename" "** No unnecessary packages found\n"
	fi	
}

##
# clean_pacman_cache()
##
clean_pacman_cache(){
	size_before=$(du -sh /var/cache/pacman/pkg/)
	number_files_before=$(ls /var/cache/pacman/pkg | wc -l)

    pacman -Sc --noconfirm >/dev/null 2>&1

    if [ ! $? == 0 ]; then
        log "$filename" "** Error to execute: pacman -Sc --noconfirm\n"
        return 1
    fi

	log "$filename" "**** Pacman Cache"
    log "$filename" "** Before:"
    log "$filename" "	- Size: $size_before" 
    log "$filename" "	- Number of files: $number_files_before"   
    log "$filename" "** After:"
    log "$filename" "	- Tamanho: $(du -sh /var/cache/pacman/pkg/)"
    log "$filename" "	- Number of files: $(ls /var/cache/pacman/pkg | wc -l) \n"
}

##
# clean_backups_and_temp_files()
# @param $1 Flag to be a interative process (1), or not (!=1).
##
clean_backups_and_temp_files(){
	INTERACTIVE=$1

    find / -iname "*~" -o -iname "*.bak" -o -iname "*.tmp" > /tmp/bkp_log
    temp="0"

    for i in $(seq 1 $(cat /tmp/bkp_log | wc -l )); do
        line=$(cat /tmp/bkp_log | head -n $i | tail -n 1)
        if [ "$INTERACTIVE" == "1" ]; then
            if [ -f "$line" ]; then
                question "Remover arquivo $line?"
            else
                question "Remover diretorio $line?"
            fi

            if [ $question == 1 ]; then
                rm -rf "$line"
                temp=$(expr $count + 1)
            fi
        else
            rm -rf "$line"
            temp=$(expr $count + 1)
        fi
    done

    rm /tmp/bkp_log

	log "$filename" "**** Backups and temp files:"
    log "$filename" "** Files removed: $temp\n"
}

###################################################################
################ MAIN PROCEDURES ##################################
###################################################################


# este script so pode ser executado como root.
if [ "$(whoami)" != "root" ] ; then	
	_s=$(which sudo 2>/dev/null)		
	echo "This scrpt must be executed as root:"
	
	if [ -n "$_s" ] ; then
		sudo "$0" $@
	else
		su -c "'$0' $@"
	fi
	exit 0
fi


##
# MAIN LOOP
##
while getopts hvb:r:c OPTION; do
	case "${OPTION}" in
		h) 
			usage
		;;
		v) 
			version
		;;
		b) 
			clean_logs
			clean_pacman_cache
			clean_backups_and_temp_files "0"
			backup ${OPTARG}
			send_mail giovanebribeiro@gmail.com
		;;
		r) 
			restore ${OPTARG}
		;;
		c)
			clean_logs
			clean_unnecessary_packages_pacman
			clean_pacman_cache
			clean_backups_and_temp_files "0"
			send_mail giovanebribeiro@gmail.com
		;;
		*) 
			usage 
		;;
	esac	
done		

